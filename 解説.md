# 概要
Nashidai Examinations Reminder (NashER) は 2021 年度，山梨大学医学部 2 年生の試験日程を毎朝ツイートしていた Twitter bot である．この文書は，この先 NashER を引き継ぐ者のために，Python で書かれた NashER のソースコードがどのような仕組みで動いていたか説明するものである．読む上で Python に関する多少の知識が必要となる．
# 仕様
NashER は毎朝 8 時，以下のように試験の日程をツイートしていた．

> 今日（10/19）は【生理学後期中間試験】当日！  
> 解剖学小テスト 8（10/22）まであと3日  
> データサイエンス試験（11/08）まであと20日  
> 生理学後期本試（01/26）まであと99日  
> 病理B本試（01/28）まであと101日  
> 実験医学本試（02/02）まであと106日  
> （[2021 年 10 月 19 日のツイート](https://twitter.com/Nash_ER_/status/1450235074490732548)）

その日に試験があれば最初に知らせ，そのあと翌日以降の試験を近い順に並べている．

また，常にリプライも受け付けており，以下のようなコマンド機能があった．
 - `!list` …… 登録されている今後の予定を全て列挙する．
 - `!new`（管理者のみ）…… 予定を追加する．
 - `!delete`（管理者のみ）…… 予定を削除する．

予定を追加するもう 1 つのコマンド `!add` の実装も検討されていたが実現しなかった．これについては後で述べる．
## 予定の扱い方
まず予定を扱う方法として最初に思いつくのは，「日付」と「予定内容」の組を並べたリストとして扱うことだろう．こうすると毎朝のツイートは以下の手順でできる：
 1. 予定のうち，日付が今日以降のものを取り出し，各々の残り日数を計算する．
 2. 残り日数が少ない順に，予定を並べ替える．
 3. 各々の予定を「今日（日付）は【予定内容】当日！」あるいは「（予定内容）（日付）まであと（残り日数）日」の形式の文字列に変換する．
 4. Twitter 字数制限の 140 文字を超えない限り，予定を近い方から文字列として連結する．

しかし，NashER ではもう少し複雑な扱い方を選んだ．

上で示した 2021 年 10 月 19 日のツイートの中に，「解剖学小テスト 8」というのがある．実はこの年度の解剖学の講義では頻繁に小テストが行われ，全部で 16 回あった．これを単なる日付と予定内容のリストに入れてしまうと，当面の予定が解剖学の小テストばかりになってしまう．字数制限（140 文字）を超えた分はツイートに含まれないため，他の試験は直前までリマインドされないことになってしまう．これを防ぐために，解剖学の小テストは，一番近い 1 つだけをツイートに含めることにしたい．

これを実現するために，予定を講義ごとに 1 つのリストにまとめ，全体がリストのリストになるようにした．ここで，個々の予定を**アイテム**，アイテムのリストを**ブロック**，ブロックのリストを**スケジュール**と呼ぶことにする．つまり，1 つめのブロック内のアイテムは解剖学の試験，2 つめのブロック内のアイテムは生理学の試験……となり，解剖学ブロック，生理学ブロック……の並んだリストが全体のスケジュールとなる．

そして，同じブロックの中からは，一番近いアイテムだけ取り出すようにする．すると，毎朝のツイートの手順は以下のようになる：

 1. スケジュール内の各ブロックについて，
    - 今日以降のアイテムが存在すれば，そのうち最も近いものを取り出して残り日数を計算する．
    - 今日以降のアイテムが存在しなければ，何も取り出さない．
 2. 取り出されたアイテムを，残り日数が少ない順に並べ替える．
 3. 各々のアイテムを「今日（日付）は【予定内容】当日！」あるいは「（予定内容）（日付）まであと（残り日数）日」の形式の文字列に変換する．
 4. Twitter 字数制限の 140 文字を超えない限り，予定を近い方から文字列として連結する．

こうすることで，解剖学の小テストを全て 1 つのブロックに入れれば，その中から一番近い小テストだけがツイートに含まれることになる．

## コマンド
NashER のコマンド機能は，リプライを 24 時間受け付け，それに応じてスケジュールの編集を行う機能である．

`!new` コマンドは，新たなブロックを作り，その中に 1 つのアイテムを追加するコマンドである．追加するアイテムの日付と内容は，例えば [`!new 2022/1/17 薬理学試験`](https://twitter.com/eIiphazhatemani/status/1454604403118260229) のように `!new` に続けて指定する．予定が正常に編集されたら，NashER はその旨をリプライで返す．

`!delete` コマンドは，指定したアイテムやブロックを削除するコマンドである．ここで，削除するアイテムやブロックを指定する手段が必要となる．日付や内容で指定すると，被ったり僅かな文字列の違い（全角半角など）が問題となる可能性があるため，代わりに番号で指定することにし，各予定の番号を知る手段として `!list` を用意した．`!list` は[このように](https://twitter.com/eIiphazhatemani/status/1435502439461908483)単独で使い，今登録されている予定を全てリプライで返すコマンドである．行頭を見ると番号（何番目のブロックの何番目のアイテムか）が分かるようになっている．この番号を用いて，[`!delete 0`](https://twitter.com/eIiphazhatemani/status/1431175449460101120) のように予定を削除する．

`!add` コマンドは，指定したブロックに新たなアイテムを追加するコマンドとして検討されていたが，実装されなかった．

また，`!new`，`!delete`，`!add` が誰でも自由に使えると問題がある．そこで，これらのコマンドは NashER がフォローしているアカウントからのリプライに限って実行した．`!list` は予定を書き換えないため，このような制限は設けなかった．

# Twitter API
プログラムから自動でツイートや返信を行うには，公式に用意された Twitter API を用いる．しかし Twitter API は近年 v1 から v2 への移行により大きく様変わりしているため，インターネット上の記事を読んでも古い情報しか書かれていないかもしれない（2021 年度の NashER も v1.1 で動いていた）．最も信頼できるのは[公式ドキュメント](https://developer.twitter.com/en/docs/twitter-api)である．

たとえば [Manage Tweets](https://developer.twitter.com/en/docs/twitter-api/tweets/manage-tweets) の項目は，ツイートを投稿する `POST` `/2/tweets` とツイートを削除する `DELETE` `/2/tweets/:id` について説明している．`POST` や `DELETE` は HTTP のリクエストメソッドであり，`/2/tweets` や `/2/tweets/:id` は URL である．

## Python のライブラリ
Python から Twitter API を叩くには，専用のライブラリを使うのがよい．v2 に対応しているライブラリの一覧は[ここ](https://developer.twitter.com/en/docs/twitter-api/tools-and-libraries/v2#python)にあるが，部分的にしか対応していないものが多いので注意する必要がある．特にツイートの投稿機能は，v2 が試験段階 (Early Access) のとき存在しなかったため，相当よく更新されているライブラリでないと対応していないと思われる．場合によっては，諦めて古い v1.1 の方を使うという選択も考えておくのが良いだろう．

## キー，トークン
Twitter API を利用して twitter アカウントを操作するには，[開発者用のページ](https://developer.twitter.com/en/portal)から Consumer Keys，Authentication Tokens を手に入れる必要がある．NashER というプロジェクトの中に Nash_ER_ という App が存在するので，そこで Keys and tokens というタブを開いて生成する．

# 外部ファイル
Nasher は，動作において自身のソースコード `nasher.py` 以外に以下の外部ファイルを必要としていた．
 - `keys` …… Twitter API のキーとトークン．
 - `schedule` …… 登録されている予定．
 - `last_id` …… 最後に受け取ったリプライの ID．
## `keys`
上で生成したキーとトークンは，ソースコード中にそのまま直書きするのではなく，別のファイルに分けて保存しておくべきだ．ソースコードを GitHub のような誰でも見られる場所に置いておくとき，API Secret や Access Token Secret まで見られると困るからだ．

`keys` は 4 行のファイルで，各行にそれぞれ API Key，API Secret，Access Token，Access Token Secret が書かれていた．Python でこれを読み出すときは，
```python
keys = open('keys').read().split('\n')
```
と書けば `keys[0]` 〜 `keys[3]` にこれらが格納される．
## `schedule`
NashER はリプライを受け付け，予定を書き加えたり削除したりする．しかし，これを Python 内の変数として保管しておくだけだと，NashER を再起動する必要に迫られたとき，それらの情報が全て失われてしまう．そのため，予定は常に外部ファイル `schedule` に保管していた．

しかし，予定は日付や文字列のリストなのに対し，ファイルに書き込めるのは単なる文字列だけなので，Python の `json` パッケージを用いて JSON で保存した．すなわち，読み出すときは
```python
schedule = json.loads(open('schedule').read())
```
となり，書き込むときは
```python
open('schedule', mode='w').write(json.dumps(schedule, indent = 4))
```
となる．JSON を使うことで，なにか問題が起こったときにファイルを開いて読んだり手動で編集したりするのも簡単になる．
## `last_id`
Twitter API の仕様上，リプライを受け取るときは，過去に受け取った中で最も新しいリプライの ID を `since_id` パラメータとして渡す必要がある．でないと，自動的に新しい方から 20 件のリプライが取得され，既に見たリプライを再び受け取ってしまうことになる．

この「過去に受け取ったリプライの ID の最大値」の情報も， NashER の再起動によって失われてほしくないので，`last_id` という名前のファイルに保存していた．読み出すときは
```python
last_id = open('last_id').read().strip()
last_id = int(last_id)
```
書き込むときは
```python
open('last_id', mode='w').write(str(last_id))
```